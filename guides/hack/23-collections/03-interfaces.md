The [concrete Hack collection classes](./classes.md) are generally derived from various interfaces. Actually, many of the methods on the concrete classes take and/or return the interfaces listed here. 

The general workflow will be that you will construct instances of the concrete classes, use either the concrete classes or interfaces in your parameter or return type annotations, and calls to methods on the concrete classes may likely return an interface.

Descriptions of each of the interface methods can be found in the [API reference](../reference/).

## Core Interfaces

These are the interfaces that allow for iteration, conversion (e.g., [`toVector`](/hack/reference/class/Map/toVector/)) and manipulation (e.g., [`filter`](/hack/reference/class/Vector/filter/)).

Interface | Description | Key Methods
----------|-------------|------------
[`Traversable<T>`](/hack/reference/interface/HH.Traversable/) | Anything that can be iterated over using something like `foreach`. A key isn't necessary, just values. | N/A
[`KeyedTraversable<Tk, Tv>`](/hack/reference/interface/HH.KeyedTraversable/) | Extends [`Traversable<T>`](/hack/reference/interface/HH.Traversable/) and requires a key to exist . | N/A
[`Container<T>`](/hack/reference/interface/HH.Container/) | Extends [`Traversable<T>`](/hack/reference/interface/HH.Traversable/), but only includes arrays and Hack collections | N/A
[`KeyedContainer<Tk, Tv>`](/hack/reference/interface/HH.KeyedContainer/) | Extends [`KeyedTraversable<Tk, Tv>`](/hack/reference/interface/HH.KeyedTraversable/), but only includes arrays and Hack collections (except for [`Set`](/hack/reference/class/Set/) and [`ImmSet`](/hack/reference/class/ImmSet/) since they don't have keys) | N/A
[`Indexish<Tk, Tv>`](/hack/reference/interface/Indexish/) | Extends [`KeyedTraversable<Tk, Tv>`](/hack/reference/interface/HH.KeyedTraversable/) and is anything that can be indexed into using square-bracket notation, except for objects that implement [`ArrayAccess`](https://secure.php.net/manual/en/class.arrayaccess.php). Usually has entities with keys of type `string` or `int`. It is somewhat common to have a method take an [`Indexish`](/hack/reference/interface/Indexish/) or return an [`Indexish`](/hack/reference/interface/Indexish/). | N/A
[`IteratorAggregate<T>`](http://php.net/manual/en/class.iteratoraggregate.php) | Extends [`Traversable<T>`](/hack/reference/interface/HH.Traversable/) and can produce an [`Iterator`](/hack/reference/interface/HH.Iterator/). Not implemented by arrays. Rarely directly used. | [`getIterator()`](http://php.net/manual/en/iteratoraggregate.getiterator.php)
[`Iterable<T>`](/hack/reference/interface/HH.Iterable/) | Extends [`IteratorAggerate<T>`](http://php.net/manual/en/class.iteratoraggregate.php) and is the **primary** interface that declares the methods that provides the capabilities for Hack collections. | [`toArray()`](/hack/reference/interface/HH.Iterable/toArray/), [`toValuesArray()`](/hack/reference/interface/HH.Iterable/toValuesArray/), [`toVector()`](/hack/reference/interface/HH.Iterable/toVector/), [`toImmVector()`](/hack/reference/interface/HH.Iterable/toImmVector/), [`toSet()`](/hack/reference/interface/HH.Iterable/toSet/), [`toImmSet()`](/hack/reference/interface/HH.Iterable/toImmSet/), [`lazy()`](/hack/reference/interface/HH.Iterable/lazy/), [`values()`](/hack/reference/interface/HH.Iterable/values/), [`map<Tm>((function(T): Tm) $callback)`](/hack/reference/interface/HH.Iterable/map/), [`filter((function(T): bool) $callback)`](/hack/reference/interface/HH.Iterable/filter/), [`zip<Tz>(Traversable<Tz> $traversable)`](/hack/reference/interface/HH.Iterable/zip/), [`take()`](/hack/reference/interface/HH.Iterable/take/), [`takeWhile()`](/hack/reference/interface/HH.Iterable/takeWhile/), [`skip()`](/hack/reference/interface/HH.Iterable/skip/), [`skipWhile()`](/hack/reference/interface/HH.Iterable/skipWhile/), [`slice()`](/hack/reference/interface/HH.Iterable/slice/), [`concat()`](/hack/reference/interface/HH.Iterable/concat/), [`firstValue()`](/hack/reference/interface/HH.Iterable/firstValue/), [`lastValue()`](/hack/reference/interface/HH.Iterable/lastValue/) 
[`KeyedIterable<Tk, Tv>`](/hack/reference/interface/HH.KeyedIterable/) | Extends [`Iterable<Tv>`](/hack/reference/interface/HH.Iterable/) and adds key capabilities | [`toKeysArray()`](/hack/reference/interface/HH.KeyedIterable/toKeysArray/), [`toMap()`](/hack/reference/interface/HH.KeyedIterable/toMap/), [`keys()`](/hack/reference/interface/HH.KeyedIterable/keys/), [`lazy()`](/hack/reference/interface/HH.KeyedIterable/lazy/), [`take()`](/hack/reference/interface/HH.KeyedIterable/take/), [`takeWhile()`](/hack/reference/interface/HH.KeyedIterable/takeWhile/), [`skip()`](/hack/reference/interface/HH.KeyedIterable/skip/), [`skipWhile()`](/hack/reference/interface/HH.KeyedIterable/skipWhile/), [`firstKey()`](/hack/reference/interface/HH.KeyedIterable/firstKey/), [`lastKey()`](/hack/reference/interface/HH.KeyedIterable/lastKey/), [`mapWithKey<Tm>(function(Tk, Tv): Tm $callback)`](/hack/reference/interface/HH.KeyedIterable/mapWithKey/), [`filterWithKey(function(Tk, Tv): bool $callback)`](/hack/reference/interface/HH.KeyedIterable/filterWithKey/), [`getIterator()`](/hack/reference/interface/HH.KeyedIterable/getIterator/), [`map<Tm>(function(T): Tm $callback)`](/hack/reference/interface/HH.KeyedIterable/map/), [`filter(function(T): bool $callback)`](/hack/reference/interface/HH.KeyedIterable/filter/), [`zip<Tz>(Traversable<Tz> $traversable)`](/hack/reference/interface/HH.KeyedIterable/zip/)

## General Collection Interfaces

These interfaces persist amongst all collections, providing basic methods for querying and adding.

Interface | Description | Key Methods
----------|-------------|------------
[`ConstCollection<T>`](/hack/reference/interface/ConstCollection/) | Read-only collection. All collections implement this interface. | [`count()`](/hack/reference/interface/ConstCollection/count/), [`isEmpty()`](/hack/reference/interface/ConstCollection/isEmpty/), [`items()`](/hack/reference/interface/ConstCollection/items/)
[`OutputCollection<T>`](/hack/reference/interface/OutputCollection/) | Mutable collection. All mutable collections implement this interface. | [`add()`](/hack/reference/interface/OutputCollection/add/), [`addAll()`](/hack/reference/interface/OutputCollection/addAll/)
[`Collection<T>`](/hack/reference/interface/HH.Collection/) | Extends [`ConstCollection<T>`](/hack/reference/interface/ConstCollection/) and [`OutputCollection<T>`](/hack/reference/interface/OutputCollection/). Combines the read-only and mutable collection behavior. | [`clear()`](/hack/reference/interface/HH.Collection/clear/)

## Specific Collection Access Interfaces

All collections have some sort of access mechanism. "Getters" for immutable collections. Adding "setters" for mutable collections. These are the interfaces that exposes those access functions.

Interface | Description | Key Methods
----------|-------------|------------
[`ConstIndexAccess<Tk, Tv>`](/hack/reference/interface/ConstIndexAccess/) | Interface for all keyed collections to enable access to its values. | [`at()`](/hack/reference/interface/ConstIndexAccess/at/), [`get()`](/hack/reference/interface/ConstIndexAccess/get/), [`containsKey()`](/hack/reference/interface/ConstIndexAccess/containsKey/)
[`IndexAccess<Tk, Tv>`](/hack/reference/interface/IndexAccess/) | Extends [`ConstIndexAccess<Tk, Tv>`](/hack/reference/interface/ConstIndexAccess/) and enables mutable collections for setting keys. | [`set()`](/hack/reference/interface/IndexAccess/set/), [`setAll()`](/hack/reference/interface/IndexAccess/setAll/), [`removeKey()`](/hack/reference/interface/IndexAccess/removeKey/)
[`ConstSetAccess<Tm>`](/hack/reference/interface/ConstSetAccess/) | Interface for all sets to enable access to its values. | [`contains()`](/hack/reference/interface/ConstSetAccess/contains/)
[`SetAccess<Tm>`](/hack/reference/interface/SetAccess/) | Extends [`ConstSetAccess<Tm>`](/hack/reference/interface/ConstSetAccess/) and enables mutable sets for removing values. | [`remove()`](/hack/reference/interface/SetAccess/remove/)
[`ConstMapAccess<Tk, Tv>`](/hack/reference/interface/ConstMapAccess/) | Extends [`ConstSetAccess<Tk>`](/hack/reference/interface/ConstSetAccess/) and [`ConstIndexAccess<Tk, Tv>`](/hack/reference/interface/ConstIndexAccess/) and enable access to a map's values. | N/A
[`MapAccess<Tk, Tv>`](/hack/reference/interface/MapAccess/) | Extends [`ConstMapAccess<Tk, Tv>`](/hack/reference/interface/ConstMapAccess/), [`SetAccess<Tk>`](/hack/reference/interface/SetAccess/) and [`IndexAccess<Tk, Tv>`](/hack/reference/interface/IndexAccess/) and enables mutable maps for setting and removing keys and values. | N\A

## Specific Collection Interfaces

Each [concrete Hack collection class](./classes.md) implements the appropriate interface listed here associated with that class.

Interface | Description | Key Methods
----------|-------------|------------
[`ConstSet<Tv>`](/hack/reference/interface/ConstSet/) | Extends [`ConstCollection<Tv>`](/hack/reference/interface/ConstCollection/), [`ConstSetAccess<Tv>`](/hack/reference/interface/ConstSetAccess/), [`Container<Tv>`](/hack/reference/interface/HH.Container/) and [`KeyedIterable<mixed, Tv>`](/hack/reference/interface/HH.KeyedIterable/) and represents a read-only set. | A [bunch](/hack/reference/interface/ConstSet/).
[`MutableSet<Tv>`](/hack/reference/interface/MutableSet/) | Extends [`ConstSet<Tv>`](/hack/reference/interface/ConstSet/), [`SetAccess`](/hack/reference/interface/SetAccess/) and [`Collection<Tv>`](/hack/reference/interface/HH.Collection/) and represents a mutable set. | A [bunch](/hack/reference/interface/MutableSet/).
[`ConstVector<Tv>`](/hack/reference/interface/ConstVector/) | Extends [`ConstCollection<Tv>`](/hack/reference/interface/ConstCollection/), [`ConstIndexAccess<int, Tv>`](/hack/reference/interface/ConstIndexAccess/), [`Indexish<int, Tv>`](/hack/reference/interface/Indexish/) and [`KeyedIterable<int, Tv>`](/hack/reference/interface/HH.KeyedIterable/) and represents a read-only vector (sequence of values). | A [bunch](/hack/reference/interface/ConstVector/).
[`MutableVector<Tv>`](/hack/reference/interface/MutableVector/) | Extends [`ConstVector<Tv>`](/hack/reference/interface/ConstVector/), [`IndexAccess<int, Tv>`](/hack/reference/interface/IndexAccess/) and [`Collection<Tv>`](/hack/reference/interface/HH.Collection/) and represents a mutable vector. | A [bunch](/hack/reference/interface/MutableVector/).
[`ConstMap<Tk, Tv>`](/hack/reference/interface/ConstMap/) | Extends `ConstCollection<Pair<Tk, Tv>>`, [`ConstMapAccess<Tk, Tv>`](/hack/reference/interface/ConstMapAccess/), [`Indexish<Tk, Tv>`](/hack/reference/interface/Indexish/)  and [`KeyedIterable<Tk, Tv>`](/hack/reference/interface/HH.KeyedIterable/) and represents a read-only mapping of keys `Tk` to values `Tv`. |  A [bunch](/hack/reference/interface/ConstMap/).
[`MutableMap<Tk, Tv>`](/hack/reference/interface/MutableMap/) | Extends [`ConstMap<Tk, Tv>`](/hack/reference/interface/ConstMap/), [`MapAccess<Tk, Tv>`](/hack/reference/interface/MapAccess/) and [`Collection<Pair<Tk, Tv>>`](/hack/reference/interface/HH.Collection/) and represents a mutable map. | A [bunch](/hack/reference/interface/MutableMap/).
